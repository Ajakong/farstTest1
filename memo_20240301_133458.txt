ポリモーフィズムを理解しておこう
配列の数が固定にしないほうがいい
特定の変数で管理しない
	charaA
	charaB
	charaC
	こういうのをやめよう
	

コンポーネント指向
	特定のオブジェクトを複数のパーツの寄せ集めで作る
	これは、設計段階では確定していない
	Unityのコンポーネントみたいなもん
	じゃあ僕らはこれをどう作ったらいいのか
	
	手っ取り早いのは、自分の内部に
	std;;vector<Object> m_object;
	みたいなものを持たせといて
	AddObject(Object* obj)
	{
		m_object.push_back(obj);
	}
	
オブジェクト指向設計で重要なのは思考も柔軟にしておく

指針となる原理はあります

SOLID原則というのがそれです
これを守れば堅牢で柔軟なプログラムになりますが守るのが難しいので参考程度にとどめておく

コンテナ(集合体)->vector,list,map,setのソートについて
mapやsetは基本的にソート済みです<-ソートできない
mapはキーで必ずソートされている。setは値でソートされている

1フレーム毎に何度も要素の数が閻行されない限りvectorを使ったほうが早い

ソートするには当然ソート関数を呼びます。
sort(bgs.begin(),bgs.end(),[](){});
ソートするときの第三関数は何を入れるのか・・・比較関数を入れます
具体的にはGreater関数を入れます。もしLess関数なら逆順です
sort関数の内部では<を用いて、どちらが手前かを判断しています
このため、BGPart側にoperator<を実装しておいて、どういう並びになるのかを
決定します

どういうときに入れ替えるのかというのを、比較演算子で決定します

bgp1 < bgp2
この演算は本来できません。なので、今回はpriorityのみで判断します
bgp1.priority<bgp2.priority
この時に入れ替わります
逆に言うと>=の時は入れ替わりません。なので、priorityを全然設定しない場合は
基本的に登録順です

emplace_backについて
基本的には、push_backみたいなもの、しかし明確な違いが
push_backは生成->コピー->コピー元を消す
emplace_backは生成だけの1ステップ(ただし、ポインタの時はnewするのでコストが変わらない)


テンプレート関係の難しいコンパイルエラー
(ぱっと見で何が起きてるのかわからない)

だいたい、コンパイルエラーでダブルクリックして、地獄のようなコードに飛んだら
たいていテンプレート系のバグ
1.コンテナ系のバグ
2.スマートポインタ系のバグ

この場合ダブルクリックしたところをいくら眺めても解決しません
なので、エラーメッセージをしっかり読みましょう

コンパイルエラーなのに治せない。どうしよう
エラーメッセージを読もう<-読んでもわからない。でもよもう(慣れ)

1.lessやgreaterがでてきたら、<><= >=関連で何か起きてると思ってください
2.やった覚えがない場合は十中八九ソート系の関数でばぐってる
	->例えば、ソートしてるのにoperater<などが定義されてない場合などに発生する
	lt <
	gt >
lt->less than-> <
gt->greater than-> >

実はHTML(XML)などでは、<>がタグを表すため、<や>が使えない
<HTML>
	<BODY>
	
	</BODY>
</HTML>

純粋に表示のために<うぃ表示したい。こういう時に困る。じゃあどうやってあれ表示しているのか

&lt -> <
&gt -> >

lessがない系のバグは
1.ソート関数
2.mapのキーやsetの値が構造体だった場合、operator<がない時に発生します

ソートってそもそも何してるの？

A=3
B=1
C=2

B
C
A
にするのがソート。配列で考えると
[0]=1
[1]=2
[2]=3

ということは何が行われているかを言うと、内部的にスワップが行われている

スワップ=swap

ソートするには「値(中身)」の入れ替えを行う必要があります

awap(int& lval,int& rval)
{
	int temp=rval;
	rval=lval;
	lval=temp;
}
これがスワップですが、これがソートの内部で行われている


