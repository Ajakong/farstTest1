UML
なじみ深いのはクラス図

ゲーム業界に関してはゆるっと知っていればいいでも、
図を書く習慣はつけておきましょう。
・人に説明するときに使う
・考えをまとめるために使う

図には
・クラス図(ゲームではこれくらいしか使わない)
・シーケンス図
・状態遷移図
・ユースケース図

よく使うクラス図のツール
PlantUML
もともとはJavaアプリですが、今
VisualStudioの拡張機能として使えます
ただし、Javaランタイムが入ってないと動かない

PlantUMLのいいところ。テキストで書いたものが図になる
->ChatGPTなどで、クラス図を書かせることもできます

最近はChatGPTだけひゃなく
・BingAI
・Bard
・Claude(Anthropicという会社が作っててAmazonが出資)

こういうものが無料で使えるので参考程度に活用

UnreaEngineのクラスの関係を今回は意識した
UEの場合は
Actorがおおもとになっています
Actorが「ゲーム中に配置できるオブジェクト」

PawnとかCharacterとかControllerCharacterとかがあります
ControllerCharacterは入力に反応するキャラクターとなります

継承関係において、親クラス側のVirtual関数を呼びたい場合
親クラス名::関数名　というような書き方で呼び出します

なぜアニメーションの名前がない時も再生しているかというと
アニメーションはキャラだけでなく、背景とかもただ同じアニメーション
を繰り返すことがあるのでアニメーション名が指定されていなくても再生している

アニメーション名が指定されていたら
アニメーション名は
jump00,jump01,jump02のように連番で管理されています

今回はostringstreamという型を使用して
このようにフォーマットされた文字を生んでいます

これは何なのか
cout<<"hello world"<<2024<<endl;
こういうものを使っていたかなと思います
この<<を使っているものは何なのかというと
「streamに追加する」という意味の演算子です
本当は左ビットシフト演算子ですが
内部で演算子オーバーロードが行われている

streamとは何か
streamってそもそも小川の流れみたいなのを表す言葉

streamというのは戻らない流れを意味して
そこにデータがポイポイ入っていくイメージ

そのイメージから出てきたのがプログラムにおけるstreamですが
これは川が流れていてそこにぽいぽいデータを投げていくと
A,B,C,D,Eとデータを投げればAが流れた後にBが流れて・・・
結果としてデータの流れの中に
ACCDEというデータが順番で履いている。そういう仕組みをstream
というようになった

例えば
cout<<"hello world"<<2024<<endl;
なら、coutというのがConsole Outの意味なので、コンソールに出力する流れに
データがポイポイ入っているイメージ

上のように書いた場Consoleに対してhello worldが流れてそのあとに２０２４が流れます
coutやsstreamなどは文字列streamなので文字列以外が流れてきたら基本的に勝手に
数値->文字列変換が行われます
その結果コンソールに
hello world2024が出力されます

これに対してostringstreamというのは文字列バッファの流れを表します

ostringstream oss;
この状態ではただの流れです

oss<<"hello world";
と書くと文字列バッファの中に"hello world"が入った状態になる
oss<<2024と書くと2024が文字列に変換され前のデータstreamに追加される形で
連結された文字列"hello world2024"となる

この変換の仕方を変えたければ#include<iomanip>というものをインクルードします

〇進数とかならiomanip使わなくても行けます
oss<<hex<<15;
と書いた場合、これはossの中身が"f"担っています
oss<<dec<<15;なら"15"
ただ、この真数表現は一度設定すると
明示的に元に戻すまで、ずっとそのまま
変えたければoss<<hex<<15<<dec;と書く必要があります

で、次に桁そろえですが、ここで
iomanipが必要になります
cout<<hex<<15;//fが出力
cout<<setw(2);これで2桁ぞろえ// fが出力
cout<<setfill('0');とやれば次に来る数値は二けたの0埋めにできる
cout<<hex<<15;//0fと出力

ただし注意点はsetwとsetfillは一度適用したら
またリセットされます。そこはhexと違うので注意

sstream:文字列を出力するフォーマット

ostringstreamは文字列ではありません。
あくまでもstreamです。ここから文字列に変換したければ
str()
という関数を使います。これは文字列型として返しますという関数です

0オリジンとか１オリジンについて
言語によって、もしくは現場のルールによって、インデックスのスタートの数値が
違うことがあります。これを「オリジン」といいます

C系の言語はまず間違いなく0オリジンです
0，1，2，3，4のように数えます
ただ人間は1,2,3,4から数え始める言語もある
例えばLuaやベーシックなど

なお、英語ではzero-based,one-basedという
なので、拾ってきたデータには気を付ける

ジャンプについて
実はジャンプは実装は簡単なのですが理屈はややこしい
ジャンプのややこしさ、重力と絡んでいることにあります
でも、重力は基本的にy軸方向にしか作用しないので

x軸とy軸を分けて考えます

まず真上にジャンプすると考えます
そうするとX方向は0なので、Yだけ考えればいい

速度と時間と移動量
速度が一定であれば

移動量=速度＊時間
なのですが、重力が常に下方向に向いています
で、皆さんが地面や床に乗っているときは重力が働いてない
わけではなく、本当は落ちようとしているんですが、地面や床が
押し返しているためにその場にとどまります。押し返してなかったら
そのままずぶずぶと、地球の中心にむかって落ちていきます

ジャンプした瞬間や、大などから足を踏み外した瞬間から
押し返す力がなくなって、速度が重力の影響を行けます

重力の影響ってそもそもなに？
重力は力です。
F=ma
F:力
m:重量
a:加速度

重力による加速度のことを重力加速度
地球上での重力加速度は9.8m/sと決められている

実際ゲームの上ではこれをそのまま使うことはありません
加速してしまうので、進む距離は二乗で進んでいきます

加速するときでもしない時でもその間に進んだ距離は
速度と時間で作ったグラフに囲まれた部分の面積

速度がもし一定Vだったら
距離=V*t;
図にすると長方形

加速していたら速度Ｖは
V=a*t;
図にすると直角三角形
三角形は底辺＊高さ/２ですが、底辺は書けた時間
高さはV=1*t
d=V*t/2=a*t*t/2
d=a*tの二乗/2

速度:Velocity
加速度:accelerate

ジャンプの場合はどうなるか
瞬間的に上方向に速度が発生する
この速度を仮にJとしておく
常に重力加速度Jが加わっているため
V=J-gt;
になります。じゃあ、まず最高点の時どうなるか
最高点の時は、上向きの速度と下向きの速度が釣り合って0になってる
最高点の時
0=J-gt
gt=J
t=J/t

高さ=K*t-1/2g*tの二乗

最高点=J*J/g-1/2g*(J/g)の二乗
=Jの二乗/g-1/2*Jの二乗/g
=1/2*Jの二乗/g
