コーディングルール

Google C++ コーディング規約
「命名規約」等を参考にするといい
 
 Unreal Engineのコーディング規約もみれる
 
きれいなコードとは(ただし、こだわりすぎない)
・ただし、統一感だけは、重視する
・一回決めたらそれに従う
	現場的には
	->引継ぎ等の時に混乱しないように
	チーム的には
	->ケンカしないように
	就活的には
	->パッチワーク疑惑を持たれないように
	
命名規約について
	基本的に英単語で変数名、関数名を作りましょう
		現場では多国籍のこともあるし、ローカライズの際に海外の企業に任せることもあります。
		この時に「Kuchu」などという
		変数名だと伝わらない(コメントは日本語でもOK)
		あと、英語を使う際は、必ずスペルを調べましょう(正確につづりは重要)
			->現場的には
				海外の人がいる可能性がある(スペルミスに厳しい)
				検索の際に引っかからない可能性があります
					実際によくあるスペルミス
						Botan->Button
						Pallet->Palette
					最悪の場合間違ったスペルが感染してコード中に広がって
						収拾がつかなくなります。なので、最初にスペルをきちんと確認しましょう
			->就活的には
				・スペルミスがないとしっかりしてるやつだと思われる
				・スペルミスが多いと->しらべるじかんをけちったなと思われます。
					->信頼性にかかわるので、英語の綴りは重視しましょう
					
					
ゲームにおける矩形について・・・
通常の矩形は

struct Rect
{
	int left;
	int top;
	int right;
	int bottom;
};
となっているのが一般的
しかし、ゲームにおいては「矩形の中心」をよく使います
このためここでは

struct Rect
{
	Position2 pos;//中心座標
	Size size;//幅、高さ
	int Left()const;//左を返す
	int Top()const;//上を返す
	int Right()const;//右を返す
	int Bottom()const;//下を返す
};
なんでこういう形にしておくかというと「当たり判定を行いやすい」というのが
あります。

通常の矩形であれば、どちらが右にあるか、左にあるかで場合分けが必要になります
それに対して、中心座標の矩形を使うと、円の当たり判定と同じく中心点間の
距離と、半径(幅/2・高さ/2)の比較で済む
もう一つは、キャラがどっちを向いていても通用する

とはいえまだ、当たり判定には使いません。まずは「カメラ」オブジェクトに使用します
「カメラ」に関しては2Dのころから意識しておいたほうがいいです。

UnityでもUE5でも2Dを作るとき「カメラ」の概念はあるので、DxLibの時も
「カメラオブジェクト」は作っておきましょう
->カメラよりカメラマンのほうが概念的に近い

行列(縦横に値が並んでるもの)
|a b|
|c d|
たいていの場合は乗算しか使わない
2*2同士の行列の乗算の結果はこれまた2*2になる
左の行と、右の列を「内積」する
|a b||e f|=|ae+bg af+bh|
|c d||g h|=|ce+dg cf+dh|			、
注意点があります
左右を入れ替えると全然違う結果になります
|1 2||5 6|=|19 22|
|3 4||7 8| |43 50|

これは座標返還に使われる。例えば回転なら
注意点は左に左にかけていくところです。

|cosθ-sinθ||x|=|xcosθ-ysinθ|
|sinθ cosθ||y| |xsinθ+ycosθ|

行列は別に同じ行列数じゃなくても乗算できますが
ルールはあります

p行q行とm行n列
を乗算する場合は(この順番で)
pとmが一致している必要がある
2行3列と3行2列はダメ
p行m列とm行n列
この計算結果はp行n列になる

左の行数より右の行数が少ない場合は
少ないほうを左に持っていく

2*2の逆行列は
det=ad-bc
|a b|=(1/det)*|d -b|
|c d|		  |-c a|

|a b|| d b|=|ad-bc -ab+ba|*(1/det)
|c d||-c a| |cd -dc cb+da|

実は回転の逆行列は簡単で転地すればOK
転地：行を列に、列を行に
DxlibだとMTransport関数で終わります
回転だけであればMTransport関数を使ったほうが圧倒的に早い
ただし、平行移動が加わると行列数が１つ増えます




std::cramp関数とは・・・特定の範囲内に値を収めるための関数
#include<algorithm>して使う

std::cramp(値、最小値、最大値)
とします

値が最小値から最大値の範囲内だったら、値がそのまま帰ります
値が最小値未満だったらｍ最小値になります
値が最大値以上だったら、最大値になります
結果的に、戻ってくる値が最小値~最大値の中に納まる

今回はカメラの座標をステージ内に収めるために使う

